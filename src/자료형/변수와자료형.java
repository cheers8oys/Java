package 자료형;

public class 변수와자료형 {

    // 자료형 선언 방법
    /*
    1. 자료형은 반드시 사용하기 전에 선언해야 한다.
    2. 자료형은 반드시 한 번만 선언해야 한다.
     */

    // 이름 짓기
    /*
    1. 영문 대소 문자와 한글을 사용할 수 있다.
    2. 특수 문자는 밑줄 _ 과 달러 $ 표시만 할 수 있다.
    3. 아라비아 숫자를 사용할 수 있다. 단, 첫 번째 글자로는 사용불가
    4. 자바에서 사용하는 예약어는 사용할 수 없다.
     */

    //변수의 생존 기간
    /*
    전역변수이냐 지역변수이냐에 따라 달라진다.
     */

    // 자료형의 종류
    /*
    논리형 : boolean
    정수형 : byte, short, int ,long
    실수형 : float, double
    문자형 : char
    객체(Object) : 배열, 클래스, 인터페이스

    자료형을 이렇게 구분해야 하는 이유는 기본 자료형과 참조 자료형의 값 저장 방식이 다르기 때문

    메모리는 목적에 따라 크게 3가지(실제로 레지스터 영역까지 4가지인데 개발자는 3가지만 알면 됨)로 구분되는데

    첫 번째 영역은 클래스 영역, 정적 영역, 상수 영역, 메서드 영역이라는 4가지 이름으로 불린다
    두 번째 영역은 스택 영역으로 변수들이 저장되는 공간이다.
    세 번재 영역은 힙 영역으로 객체들이 저장되는 공간이다.

    기본 자료형과 참조 자료형 변수 둘다 공간이 스택 메모리에 생성되지만 저장되는 값의 의미가 다르다.
    기본 자료형은 스택 메모리에 생성된 공간에 실제 변숫값을 저장하는 반면
    참조 자료형은 실제 데이터값은 힙 메모리에 저장하고, 스택 메모리 공간에는 실제 변숫값이 저장된
    힙 메모리의 위칫값을 저장한다
     */

    //기본 자료형의 메모리 크기와 저장할 수 있는 값의 범위
    /*

    1byte = 8bit

    <부울대수>
    boolean / 1byte / true, false

    <정수>
    byte / 1byte / -2^7 ~ 2^7-1
    short / 2byte / -2^15 ~ 2^15-1
    int / 4byte / -2^31 ~ 2^31-1
    long / 8byte / -2^63 ~ 2^63-1

    <실수>
    float / 4byte / +- (1.40 * 10^-45 ~ 3.40*10^38)
    double / 8byte / +- (4.94 * 10^-324 ~ 1.79 * 10^308)

    <문자>
    char / 2byte / 유니코드 문자( 0 ~ 2^16-1)

   [똑같은 정수를 저장하는데 왜 자료형이 4개나 필요할까?]
   크기가 다양한 그릇으로 식사하는 것과 같은 원리
   크기가 큰 하나의 그릇만 있다면 콩 하나를 담기엔 불필요하게 크고
   크기가 작은 그릇만 있다면 넘쳐흘러넘칠 수 있기 때문에 여러 크기의 자료형을 사용하는 이유이다.

   자바는 대입 연산자를 기준으로 양쪽 자료형이 일치해야 하는데
   크기가 작은 자료형을 큰 자료형으로 대입하면 컴파일러가 자동 타입 변환 수행

   실수 자료형은 기본적으로 double로 인식하고 float을 사용하고싶다면 리터럴 뒤에 f 붙여야 함.

   문자 자료형은 메모리에 문자 저장이 안되므로 문자에 해당하는 특정 정수값인 유니코드를 저장


    [자바에선 진법 표기가 다양한데, 진법 변환 방법도 쉬울까?]

    10진수 : 숫자
    2진수 : 0b + 숫자
    8진수 : 0 + 숫자
    16진수 : 0x + 숫자

    10진수 -> 2진수 / 8진수 / 16진수 문자열
    Integer.toBinaryString(data)
    Integer.toOctalString(data)
    Integer.toHexString(data)

    2진수 / 8진수 / 16진수 문자열 -> 10진수 정수
    Integer.parseInt("1010" ,2);
    Integer.parseInt("12", 8);
    Integer.parseInt("a", 16);

    [정수형 자료형의 서큘러 구조]

    정수형 자료형을 작은 범위의 자료형으로 캐스팅할 때는 반대쪽 끝에서부터 다시 시작하는 서큘러 구조를 보이낟
    즉, 정숫값 128(127+1)을 byte 자료형으로 다운캐스팅하면 byte 자료형의 범위에서 반대쪽 끝인 -128로 변환된다.

    // 기본 자료형 간의 연산
    boolean을 제외한 나머지 기본 자료형은 서로 연산할 수 있다.
    이때 모든 연산은 같은 자료형끼리만 가능하며 연산 결과 역시 같은 자료형으로 나온다.
    단, int보다 작은 자료형끼리의 연산은 int로 나온다. CPU의 연산 최소 단위가 int이기 때문이다.

     */
}
